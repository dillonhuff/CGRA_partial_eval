//
//--------------------------------------------------------------------------------
//          THIS FILE WAS AUTOMATICALLY GENERATED BY THE GENESIS2 ENGINE        
//  FOR MORE INFORMATION: OFER SHACHAM (CHIP GENESIS INC / STANFORD VLSI GROUP)
//    !! THIS VERSION OF GENESIS2 IS NOT FOR ANY COMMERCIAL USE !!
//     FOR COMMERCIAL LICENSE CONTACT SHACHAM@ALUMNI.STANFORD.EDU
//--------------------------------------------------------------------------------
//
//  
//	-----------------------------------------------
//	|            Genesis Release Info             |
//	|  $Change: 11904 $ --- $Date: 2013/08/03 $   |
//	-----------------------------------------------
//	
//
//  Source file: /Users/dillon/VerilogWorkspace/CGRAGenerator/hardware/generator_z/memory_core/memory_core.vp
//  Source template: memory_core
//
// --------------- Begin Pre-Generation Parameters Status Report ---------------
//
//	From 'generate' statement (priority=5):
// Parameter ddepth 	= 1024
// Parameter dwidth 	= 16
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Command Line input (priority=4):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From XML input (priority=3):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Config File input (priority=2):
//
// ---------------- End Pre-Generation Pramameters Status Report ----------------

///////////////////////////////////////////////////////////////////
// CGRA memory generator
//////////////////////////////////////////////////////////////////


`define xassert(condition, message)

//if(condition) begin $display(message); $finish(1); end


// dwidth (_GENESIS2_INHERITANCE_PRIORITY_) = 16
//
// ddepth (_GENESIS2_INHERITANCE_PRIORITY_) = 0x400
//


module memory_core_unq1(
clk,
reset,
config_addr,
config_data,
config_en,
data_in,
data_out,
wen_in,
ren_in,
valid_out,
chain_in,
chain_out,
chain_wen_in,
chain_valid_out,
almost_full,
almost_empty,
addr_in
);

input clk;
input reset;
input config_en;
input wen_in;
input ren_in;
input chain_wen_in;
input [31:0] config_addr;
input [31:0] config_data;
input [15:0] data_in;
input [15:0] chain_in;
input [15:0] addr_in;

output chain_valid_out;
output [15:0] chain_out;
output reg valid_out;
output reg almost_full;
output reg almost_empty;
output reg [15:0] data_out;

wire  [2:0] mode;
wire  [2:0] tile_en;
wire [13:0] depth;
wire  [3:0] almost_count;
wire        enable_chain;

wire gclk;
wire wen_in_int;
wire mem_cen0;
wire mem_cen1;

wire lb_valid_out;
wire fifo_valid_out;
wire lb_almost_full;
wire fifo_almost_full;
wire lb_almost_empty;
wire fifo_almost_empty;
wire lb_wen;
wire lb_ren;
wire fifo_wen;
wire fifo_ren;

wire [15:0] data_in_int;
wire [15:0] mem_data_out0;
wire [15:0] mem_data_out1;

wire [15:0] lb_addr;
wire [15:0] fifo_addr;
wire [31:0] lb_mem_data_out;
wire [31:0] fifo_mem_data_out;
wire [15:0] lb_out;
wire [15:0] fifo_out;

reg [15:0] mem_data_in0;
reg [15:0] mem_data_in1;
reg [31:0] config_mem;
reg [15:0] mem_addr;
reg mem_ren0;
reg mem_wen0;
reg mem_ren1;
reg mem_wen1;
reg sram_sel;

assign mode = config_mem[1:0];
assign tile_en = config_mem[2];
assign depth = config_mem[15:3];
assign almost_count = config_mem[19:16];
assign enable_chain = config_mem[19];

assign gclk = clk & (tile_en==1'b1);


assign data_in_int = (enable_chain==1'b1)?chain_in:data_in;
assign wen_in_int = WENHACK;
assign chain_out = data_out;
assign chain_valid_out = valid_out;


// WENHACK code, please do not remove w/o checking with steveri@stanford.edu!
// At the last minute, run.csh can modify wen_int assignment above
// to read "assign  wen_in_int = WENHACK" instead
reg WENHACK;
always @(posedge clk or posedge reset) begin
   if (reset==1'b1) begin
     WENHACK = 1'b0;
   end else if (data_in != 16'b0) begin
     WENHACK = 1'b1;
   end
end


always @(posedge clk or posedge reset) begin
  if (reset==1'b1) begin
    config_mem <= 32'd0;
  end else begin
    if (config_en==1'b1) begin
       case (config_addr[31:24])
         8'd0: config_mem[31:0] <= config_data;
       endcase
    end
  end
end


always @(*) begin
  case (mode)
    2'd0: begin
      mem_wen0 <= lb_wen;
      mem_ren0 <= lb_ren;
      mem_wen1 <= lb_wen;
      mem_ren1 <= lb_ren;
      mem_addr <= lb_addr;
      {mem_data_in1,mem_data_in0} <= lb_mem_data_out;
      data_out <= lb_out; 
      valid_out <= lb_valid_out;
      almost_full <= lb_almost_full;
      almost_empty <= lb_almost_empty;
    end
    2'd1: begin
      mem_wen0 <= fifo_wen;
      mem_ren0 <= fifo_ren;
      mem_wen1 <= fifo_wen;
      mem_ren1 <= fifo_ren;
      mem_addr <= fifo_addr;
      {mem_data_in1,mem_data_in0} <= fifo_mem_data_out;
      data_out <= fifo_out;
      valid_out <= fifo_valid_out;
      almost_full <= fifo_almost_full;
      almost_empty <= fifo_almost_empty;
    end
    2'd2: begin
      mem_wen0 <= ~addr_in[9];
      mem_ren0 <= 1'b1;
      mem_wen1 <= addr_in[9];
      mem_ren1 <= 1'b1;
      mem_addr <= addr_in;      
      mem_data_in0 <= data_in;
      mem_data_in1 <= data_in;
      data_out <= (sram_sel==1'b1)?mem_data_in1:mem_data_in0;
      valid_out <= 1'b1;  
      almost_full <= 1'b0; 
      almost_empty <= 1'b0; 
    end
    default: begin
      mem_wen0 <= 1'b0; 
      mem_ren0 <= 1'b0;
      mem_wen1 <= 1'b0; 
      mem_ren1 <= 1'b1;
      mem_addr <= 16'd0;      
      mem_data_in0 <= 16'd0;
      mem_data_in1 <= 16'd0;
      data_out <= 16'd0;
      valid_out <= 1'b0;
      almost_full <= 1'b0;
      almost_empty <= 1'b0;
    end
  endcase
end

always @(posedge clk) begin
  sram_sel <= addr_in[9];
end

assign mem_cen0 = mem_wen0 | mem_ren0;
assign mem_cen1 = mem_wen1 | mem_ren1;


linebuffer_control_unq1  linebuffer_control
(
.clk(gclk),
.reset(reset),
.data_in(data_in_int),
.wen(wen_in_int),
.data_out(lb_out),
.stall_read(ren_in),
.valid(lb_valid_out),
.almost_full(lb_almost_full),
.almost_empty(lb_almost_empty),
.almost_count(almost_count),
.depth(depth),
.addr_to_mem(lb_addr),
.data_to_mem(lb_mem_data_out),
.data_from_mem({mem_data_out1,mem_data_out0}),
.wen_to_mem(lb_wen),
.ren_to_mem(lb_ren)
);

fifo_control_unq1  fifo_control
(
.clk(gclk),
.reset(reset),
.data_in(data_in_int),
.wen(wen_in_int),
.data_out(fifo_out),
.stall_read(ren_in),
.valid(fifo_valid_out),
.almost_full(fifo_almost_full),
.almost_empty(fifo_almost_empty),
.almost_count(almost_count),
.depth(depth),
.addr_to_mem(fifo_addr),
.data_to_mem(fifo_mem_data_out),
.data_from_mem({mem_data_out1,mem_data_out0}),
.wen_to_mem(fifo_wen),
.ren_to_mem(fifo_ren)
);

mem_unq1  mem_inst0
(
.data_out(mem_data_out0),
.data_in(mem_data_in0),
.clk(gclk),
.cen(mem_cen0),
.wen(mem_wen0),
.addr(mem_addr[8:0])
);

mem_unq1  mem_inst1
(
.data_out(mem_data_out1),
.data_in(mem_data_in1),
.clk(gclk),
.cen(mem_cen1),
.wen(mem_wen1),
.addr(mem_addr[8:0])
);
endmodule


